/*
 * Nebula Enrollment over Secure Transport - OpenAPI 3.0
 *
 * This is a simple Public Key Infrastructure Management Server based on the RFC7030 Enrollment over Secure Transport Protocol for a Nebula Mesh Network. The Service accepts requests from mutually authenticated TLS-PSK connections to create Nebula Certificates for the client, either by signing client-generated Nebula Public Keys or by generating Nebula key pairs and signing the server-generated Nebula public key and to create Nebula configuration files for the specific client. This Service acts as a Facade for the Nebula CA service (actually signign or creating the Nebula keys) and the Nebula Config service (actually creating the nebula Config. files).
 *
 * API version: 0.1.1
 * Contact: gianmarco.decola@studio.unibo.it
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
//TODO: refactor logging and fix concurrent writing on file
package nest_service

import (
	"bufio"
	"crypto/ed25519"
	"log"
	"net/http"
	"os"
	"regexp"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/m4rkdc/nebula_est/pkg/models"
	"github.com/slackhq/nebula/cert"
	"google.golang.org/protobuf/proto"
)

var (
	Hostnames_file string = "config/hostnames"
	Log_file       string = "log/nest_service.log"
	Service_ip     string = "localhost"
	Service_port   string = "8080"
)

const (
	ENROLL = iota
	SERVERKEYGEN
	RENROLL
)

func isValidHostname(str, filepath string) bool {

	b, err := os.ReadFile(filepath)
	if err != nil {
		panic(err)
	}

	isValid, err := regexp.Match(str, b)
	if err != nil {
		panic(err)
	}
	return isValid
}

func verifyCsr(csr models.NebulaCsr, hostname string, option int) (int, models.ApiError) {
	if csr.Hostname != hostname {
		log.Printf("Unhautorized. The hostname in the URL and the one in the Nebula CSR are different.\n")
		return http.StatusUnauthorized, models.ApiError{Code: 403, Message: "Unhautorized. The hostname in the URL and the one in the Nebula CSR are different."}
	}
	if option != RENROLL && csr.Rekey {
		log.Println("Bad Request. Rekey is true.")
		return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. Rekey is true"}
	}

	switch option {
	case ENROLL:
		if csr.ServerKeygen {
			log.Println("Bad Request. ServerKeygen is true.")
			return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. ServerKeygen is true. If you wanted to enroll with a server keygen, please visit https://" + Service_ip + ":" + Service_port + "/" + "/ncsr/" + hostname + "/serverkeygen"}
		}
	case SERVERKEYGEN:
		if !csr.ServerKeygen {
			log.Println("Bad Request. ServerKeygen is false.")
			return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. ServerKeygen is false. If you wanted to enroll with a client-generated nebula public key, please visit https://" + Service_ip + ":" + Service_port + "/" + "/ncsr/" + hostname + "/enroll"}
		}
		return 0, models.ApiError{}
	case RENROLL:
		if !csr.Rekey || (csr.Rekey && csr.ServerKeygen) {
			return 0, models.ApiError{}
		}
	}

	if len(csr.PublicKey) == 0 {
		log.Println("Bad Request. Public key is not provided.")
		return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. Public key is not provided"}
	}
	if len(csr.Pop) == 0 {
		log.Println("Bad Request. Proof of Possession is not provided.")
		return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. Proof of Possession is not provided"}
	}

	var csr_ver = models.RawNebulaCsr{
		ServerKeygen: &csr.ServerKeygen,
		Rekey:        &csr.Rekey,
		Hostname:     csr.Hostname,
		PublicKey:    csr.PublicKey,
	}

	b, err := proto.Marshal(&csr_ver)

	if err != nil {
		log.Fatalln("Failed to encode Nebula CSR:", err)
		return http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()}
	}

	if !ed25519.Verify(csr.PublicKey, b, csr.Pop) {
		log.Println("Bad Request. Proof of Possession is not valid.")
		return http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. Proof of Possession is not valid"}
	}
	return 0, models.ApiError{}
}

func Enroll(c *gin.Context) {
	logF, err := os.OpenFile(Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf("Error opening file: %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	log.SetOutput(logF)
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	defer logF.Close()

	log.Println("Nebula Enroll request received")

	hostname := c.Params.ByName("hostname")
	if hostname == "" {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no hostname provided"})
		log.Printf("Bad request: %v. No hostname provided\n", err)
		return
	}

	b, err := os.ReadFile("ncsr/" + hostname)
	if err == nil {
		log.Fatalf("Error opening /ncsr/"+hostname+": %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	if isPending, _ := regexp.Match(string(models.PENDING), b); !isPending {
		log.Println("The hostname " + hostname + " has already enrolled")
		c.JSON(http.StatusConflict, models.ApiError{Code: 409, Message: "Conflict. This hostname has already enrolled. If you want to re-enroll, please visit https:https://" + Service_ip + ":" + Service_port + "/ncsr/" + hostname + "/reenroll"})
		return
	}

	var csr models.NebulaCsr

	if err := c.BindJSON(&csr); err != nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no Nebula Certificate Signing Request provided"})
		log.Printf("Bad request: %v. No Nebula Certificate Signing Request provided\n", err)
		return
	}

	status_code, api_error := verifyCsr(csr, hostname, ENROLL)
	if status_code != 0 {
		c.JSON(status_code, api_error)
		return
	}

	//TODO: send the CSR to the Nebula CA to be signed which will return a cert.nebulaCertificate
	var nebula_cert cert.NebulaCertificate

	//TODO: send a request to the Conf service to generate this client's nebula configuration file
	var nebula_conf []byte

	var csr_resp = models.NebulaCsrResponse{
		NebulaCert: nebula_cert,
		NebulaConf: nebula_conf,
	}

	file, err := os.OpenFile("ncsr/"+hostname, os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("Could not write to file: %v", err)
	}
	defer file.Close()

	file.WriteString(string(models.COMPLETED) + "\n")
	file.WriteString(nebula_cert.Details.NotAfter.String())
	c.JSON(http.StatusOK, csr_resp)
}

func NcsrApplication(c *gin.Context) {
	logF, err := os.OpenFile(Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf("Error opening file: %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	defer logF.Close()

	log.SetOutput(logF)
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	log.Println("Nebula CSR Application received")

	var hostname string = ""
	if err := c.BindJSON(&hostname); err != nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no hostname provided"})
		log.Printf("Bad request: %v. No hostname provided\n", err)
		return
	}

	if _, err := os.Stat("ncsr/" + hostname); err == nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Conflict. A Nebula CSR for the hostname you provided already exists. If you want to re-enroll, please visit https://nebula_est/ncsr/" + hostname + "/reenroll"})
		log.Printf("Conflict: %v. Conflict. A Nebula CSR for the provided hostname already exists.\n", err)
		return
	}

	if !isValidHostname(hostname, Hostnames_file) {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: The hostname you provided was not found in the Configuration service list"})
		log.Printf("Bad request: %v. Hostname not found in Config service list\n", err)
		return
	}

	if _, err := os.Stat("ncsr/" + hostname); err == nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Conflict. A Nebula CSR for the hostname you provided already exists. If you want to re-enroll, please visit https://" + Service_ip + ":" + Service_port + "/ncsr/" + hostname + "/reenroll"})
		log.Printf("Conflict: %v. A Nebula CSR for the provided hostname already exists.\n", err)
		return
	}

	applicationFile, err := os.OpenFile("ncsr/"+hostname, os.O_CREATE|os.O_WRONLY, 0600)
	if err == nil {
		log.Fatalf("Error creating /ncsr/"+hostname+": %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}
	if _, err := applicationFile.WriteString(string(models.PENDING)); err != nil {
		log.Fatalf("Could not write "+string(models.PENDING)+" status to  /ncsr/"+hostname+": %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	c.Header("Location", "http://"+Service_ip+":"+Service_port+"/ncsr/"+hostname)
	c.Status(http.StatusCreated)
}

func NcsrStatus(c *gin.Context) {
	logF, err := os.OpenFile(Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf("Error opening file: %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	defer logF.Close()

	log.SetOutput(logF)
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	hostname := c.Params.ByName("hostname")
	if hostname == "" {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no hostname provided"})
		log.Printf("Bad request: %v. No hostname provided\n", err)
		return
	}

	log.Println("Nebula CSR Status request received for hostname: " + hostname)

	file, err := os.OpenFile("ncsr/"+hostname, os.O_RDWR|os.O_TRUNC, 0600)
	if err != nil {
		c.JSON(http.StatusNotFound, models.ApiError{Code: 404, Message: "Not found. Could not find an open Nebula CSR application for the specified hostname. If you want to enroll, provide your hostname to http:" + Service_ip + ":" + Service_port + "/ncsr"})
		log.Printf("Not found: %v Could not find an open Nebula CSR application for %s. If you want to enroll, provide your hostname to http:%s:%s/ncsr", err, hostname, Service_ip, Service_port)
		return
	}
	defer file.Close()

	fileScanner := bufio.NewScanner(file)

	fileScanner.Split(bufio.ScanLines)
	var fileLines []string
	for fileScanner.Scan() {
		fileLines = append(fileLines, fileScanner.Text())
	}

	if len(fileLines) == 2 {
		notAfter, err := time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", fileLines[1])
		if err != nil {
			log.Fatalf("Error parsing notAfter field in file: %v\n", err)
			c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
			panic(err)
		}
		if time.Until(notAfter) < 0 {
			fileLines[0] = string(models.EXPIRED)
			for _, s := range fileLines {
				file.WriteString(s + "\n")
			}
		}
	}
	c.JSON(http.StatusOK, fileLines[0])
}

func Reenroll(c *gin.Context) {
	logF, err := os.OpenFile(Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf("Error opening file: %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	defer logF.Close()

	log.SetOutput(logF)
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	log.Println("Nebula Re-enroll request received")

	hostname := c.Params.ByName("hostname")
	if hostname == "" {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no hostname provided"})
		log.Printf("Bad request: %v. No hostname provided\n", err)
		return
	}

	b, err := os.ReadFile("ncsr/" + hostname)
	if err == nil {
		log.Fatalf("Error opening /ncsr/"+hostname+": %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	if isPending, _ := regexp.Match(string(models.PENDING), b); isPending {
		log.Println("The hostname " + hostname + " has not yet finished the first enrollment phase, cannot re-enroll")
		c.JSON(http.StatusConflict, models.ApiError{Code: 409, Message: "Conflict. This hostname has not yet finished enrolling. If you want to do so, please visit https://" + Service_ip + ":" + Service_port + "/ncsr/" + hostname + "/enroll"})
		return
	}

	var csr models.NebulaCsr

	if err := c.BindJSON(&csr); err != nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no Nebula Certificate Signing Request provided"})
		log.Printf("Bad request: %v. No Nebula Certificate Signing Request provided\n", err)
		return
	}

	status_code, api_error := verifyCsr(csr, hostname, ENROLL)
	if status_code != 0 {
		c.JSON(status_code, api_error)
		return
	}

}

func Serverkeygen(c *gin.Context) {
	logF, err := os.OpenFile(Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf("Error opening file: %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	defer logF.Close()

	log.SetOutput(logF)
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	log.Println("Nebula Enroll request received")

	hostname := c.Params.ByName("hostname")
	if hostname == "" {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no hostname provided"})
		log.Printf("Bad request: %v. No hostname provided\n", err)
		return
	}

	b, err := os.ReadFile("ncsr/" + hostname)
	if err == nil {
		log.Fatalf("Error opening /ncsr/"+hostname+": %v\n", err)
		c.JSON(http.StatusInternalServerError, models.ApiError{Code: 500, Message: "Internal server error: " + err.Error()})
		panic(err)
	}

	if isPending, _ := regexp.Match(string(models.PENDING), b); !isPending {
		log.Println("The hostname " + hostname + " has already enrolled")
		c.JSON(http.StatusConflict, models.ApiError{Code: 409, Message: "Conflict. This hostname has already enrolled. If you want to re-enroll, please visit https:https://" + Service_ip + ":" + Service_port + "/ncsr/" + hostname + "/reenroll"})
		return
	}

	var csr models.NebulaCsr

	if err := c.BindJSON(&csr); err != nil {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad request: no Nebula Certificate Signing Request provided"})
		log.Printf("Bad request: %v. No Nebula Certificate Signing Request provided\n", err)
		return
	}

	if csr.Hostname != hostname {
		c.JSON(http.StatusUnauthorized, models.ApiError{Code: 403, Message: "Unhautorized. The hostname in the URL and the one in the Nebula CSR are different."})
		log.Printf("Unhautorized: %v. The hostname in the URL and the one in the Nebula CSR are different.\n", err)
		return
	}

	if csr.Rekey {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. Rekey is true"})
		log.Println("Bad Request. Rekey is true.")
		return
	}

	if !csr.ServerKeygen {
		c.JSON(http.StatusBadRequest, models.ApiError{Code: 400, Message: "Bad Request. ServerKeygen is false. If you wanted to enroll with a client-generated nebula public key, please visit https://" + Service_ip + ":" + Service_port + "/" + "/ncsr/" + hostname + "/enroll"})
		log.Println("Bad Request. ServerKeygen is false.")
		return
	}

	//TODO: send a request to the Nebula CA Service to generate a Nebula key pair
	var nebula_cert cert.NebulaCertificate

	//TODO: send a request to the Conf service to generate this client's nebula configuration file
	var nebula_conf []byte

	var csr_resp = models.NebulaCsrResponse{
		NebulaCert: nebula_cert,
		NebulaConf: nebula_conf,
	}

	file, err := os.OpenFile("ncsr/"+hostname, os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("Could not write to file: %v", err)
	}
	defer file.Close()

	file.WriteString(string(models.COMPLETED) + "\n")
	file.WriteString(nebula_cert.Details.NotAfter.String())
	c.JSON(http.StatusOK, csr_resp)
}
