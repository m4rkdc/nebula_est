/*
 * Nebula Enrollment over Secure Transport - OpenAPI 3.0
 *
 * This is a simple Public Key Infrastructure Management Server based on the RFC7030 Enrollment over Secure Transport Protocol for a Nebula Mesh Network. The Service accepts requests from mutually authenticated TLS-PSK connections to create Nebula Certificates for the client, either by signing client-generated Nebula Public Keys or by generating Nebula key pairs and signing the server-generated Nebula public key and to create Nebula configuration files for the specific client. This Service acts as a Facade for the Nebula CA service (actually signign or creating the Nebula keys) and the Nebula Config service (actually creating the nebula Config. files).
 *
 * API version: 0.1.1
 * Contact: gianmarco.decola@studio.unibo.it
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"github.com/gin-gonic/gin"
	nest "github.com/m4rkdc/nebula_est/app/nest_service"
	"github.com/m4rkdc/nebula_est/pkg/models"
)

func getHostnames() ([]string, error) {
	resp, err := http.Get("http://" + nest.Conf_service_ip + ":" + nest.Conf_service_port + "/hostnames")
	if err != nil {
		return nil, err
	}

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var error_response *models.ApiError
	if json.Unmarshal(b, error_response) != nil {
		return nil, error_response
	}
	var response []string
	err = json.Unmarshal(b, &response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func checkHostnamesFile() error {
	if _, err := os.Stat(nest.Hostnames_file); err != nil {
		log.Printf("%s doesn't exist. Creating it and requesting the cert from Nebula CA service\n", nest.Hostnames_file)
		hostnames, err := getHostnames()
		if err != nil {
			log.Fatalf("There has been an error with the hostnames request: %v", err.Error())
			return err
		}

		file, err := os.OpenFile(nest.Hostnames_file, os.O_WRONLY|os.O_TRUNC, 0600)
		if err != nil {
			log.Fatalf("Could not write to file: %v", err)
			return err
		}
		defer file.Close()

		for _, h := range hostnames {
			file.WriteString(h + "\n")
		}
	}
	return nil
}

func setupLogger(router *gin.Engine) error {
	logF, err := os.OpenFile(nest.Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		return err
	}

	gin.ForceConsoleColor()
	router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
		Output: io.MultiWriter(logF, os.Stdout),
	}))
	return nil
}

func isExecOwner(mode os.FileMode) bool {
	return mode&0100 != 0
}

func setupNebula() error {
	info, err := os.Stat(nest.Nebula_folder + "nebula")
	if err != nil {
		fmt.Printf("%s doesn't exist. Cannot proceed. Please provide the nebula bin to the service before starting it\nExiting...", nest.Nebula_folder+"nebula")
		return err
	}
	if !isExecOwner(info.Mode()) {
		os.Chmod(nest.Nebula_folder+"nebula", 0700)
	}

	cmd := exec.Command(nest.Nebula_folder+"nebula", "-config "+nest.Nebula_folder+"config.yml")
	if err = cmd.Run(); err != nil {
		return err
	}

	interfaces, err := net.Interfaces()

	if err != nil {
		fmt.Printf("Could'nt check information about host interfaces\n")
		return err
	}

	var found bool = false
	for _, i := range interfaces {
		if strings.Contains(strings.ToLower(i.Name), "nebula") {
			found = true
			break
		}
	}

	if found {
		return nil
	}
	return errors.New("could not setup a nebula tunnel")
}

func main() {
	if val, ok := os.LookupEnv("LOG_FILE"); ok {
		nest.Log_file = val
	}
	fmt.Printf("Service started\n\n")

	if val, ok := os.LookupEnv("SERVICE_IP"); ok {
		nest.Service_ip = val
	}
	if val, ok := os.LookupEnv("SERVICE_PORT"); ok {

		nest.Service_port = val
	}
	if val, ok := os.LookupEnv("HOSTNAMES_FILE"); ok {
		nest.Hostnames_file = val
	}
	if val, ok := os.LookupEnv("CA_CERT_FILE"); ok {
		nest.Ca_cert_file = val
	}
	if val, ok := os.LookupEnv("NEBULA_FOLDER"); ok {
		nest.Nebula_folder = val
	}

	if err := nest.CheckCaCertFile(); err != nil {
		fmt.Println("Could not contact the CA service")
		os.Exit(2)
	}
	if err := checkHostnamesFile(); err != nil {
		fmt.Println("Could not contact the Conf service")
		os.Exit(3)
	}

	if _, err := os.Stat("/ncsr"); err != nil {
		if err := os.Mkdir("/ncsr", 0700); err != nil {
			fmt.Printf("Couldn't create /ncsr directory")
			os.Exit(4)
		}
	}

	if _, err := os.Stat(nest.Nebula_folder + "nest_service.crt"); err != nil {
		fmt.Printf("Cannot find NEST service Nebula certificate\n")
		os.Exit(5)
	}
	if _, err := os.Stat(nest.Nebula_folder + "nest_service.key"); err != nil {
		fmt.Printf("Cannot find NEST service Nebula key\n")
		os.Exit(6)
	}

	if _, err := os.Stat(nest.Nebula_folder + "ca.crt"); err != nil {
		fmt.Printf("Cannot find NEST Nebula CA crt\n")
		os.Exit(7)
	}

	if _, err := os.Stat(nest.Nebula_folder + "config.yml"); err != nil {
		fmt.Printf("Cannot find NEST Nebula config\n")
		os.Exit(8)
	}

	if err := setupNebula(); err != nil {
		fmt.Printf("There was an error setting up the Nebula tunnel:%v\n", err.Error())
		os.Exit(9)
	}

	fmt.Println("Service setup finished")

	router := gin.Default()
	setupLogger(router)

	for _, r := range nest.Service_routes {
		switch r.Method {
		case "GET":
			router.GET(r.Pattern, r.HandlerFunc)
		case "POST":
			router.POST(r.Pattern, r.HandlerFunc)
		}
	}

	router.Run(nest.Service_ip + ":" + nest.Service_port)
}
