/*
 * Nebula Enrollment over Secure Transport - OpenAPI 3.0
 *
 * This is a simple Public Key Infrastructure Management Server based on the RFC7030 Enrollment over Secure Transport Protocol for a Nebula Mesh Network. The Service accepts requests from mutually authenticated TLS-PSK connections to create Nebula Certificates for the client, either by signing client-generated Nebula Public Keys or by generating Nebula key pairs and signing the server-generated Nebula public key and to create Nebula configuration files for the specific client. This Service acts as a Facade for the Nebula CA service (actually signign or creating the Nebula keys) and the Nebula Config service (actually creating the nebula Config. files).
 *
 * API version: 0.1.1
 * Contact: gianmarco.decola@studio.unibo.it
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
	nest "github.com/m4rkdc/nebula_est/app/nest_service"
	"github.com/m4rkdc/nebula_est/pkg/models"
)

func getHostnames() ([]string, error) {
	resp, err := http.Get("http://" + nest.Conf_service_ip + ":" + nest.Conf_service_port + "/hostnames")
	if err != nil {
		return nil, err
	}

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var error_response *models.ApiError
	if json.Unmarshal(b, error_response) != nil {
		return nil, error_response
	}
	var response []string
	err = json.Unmarshal(b, &response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func checkHostnamesFile() error {
	if _, err := os.Stat(nest.Hostnames_file); err != nil {
		log.Printf("%s doesn't exist. Creating it and requesting the cert from Nebula CA service\n", nest.Hostnames_file)
		hostnames, err := getHostnames()
		if err != nil {
			log.Fatalf("There has been an error with the hostnames request: %v", err.Error())
			return err
		}

		file, err := os.OpenFile(nest.Hostnames_file, os.O_WRONLY|os.O_TRUNC, 0600)
		if err != nil {
			log.Fatalf("Could not write to file: %v", err)
			return err
		}
		defer file.Close()

		for _, h := range hostnames {
			file.WriteString(h + "\n")
		}
	}
	return nil
}

func setupLogger(router *gin.Engine) error {
	logF, err := os.OpenFile(nest.Log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		return err
	}

	gin.ForceConsoleColor()
	router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
		Output: io.MultiWriter(logF, os.Stdout),
	}))
	return nil
}

func main() {
	if val, ok := os.LookupEnv("LOG_FILE"); ok {
		nest.Log_file = val
	}
	fmt.Printf("Service started\n\n")

	if val, ok := os.LookupEnv("SERVICE_IP"); ok {
		nest.Service_ip = val
	}
	if val, ok := os.LookupEnv("SERVICE_PORT"); ok {

		nest.Service_port = val
	}
	if val, ok := os.LookupEnv("HOSTNAMES_FILE"); ok {
		nest.Hostnames_file = val
	}
	if val, ok := os.LookupEnv("CA_CERT_FILE"); ok {
		nest.Ca_cert_file = val
	}

	if err := nest.CheckCaCertFile(); err != nil {
		fmt.Println("Could not contact the CA service")
		os.Exit(2)
	}
	if err := checkHostnamesFile(); err != nil {
		fmt.Println("Could not contact the Conf service")
		os.Exit(3)
	}

	if _, err := os.Stat("/ncsr"); err != nil {
		if err := os.Mkdir("/ncsr", 0700); err != nil {
			fmt.Printf("Couldn't create /ncsr directory")
			os.Exit(4)
		}
	}

	fmt.Println("Service setup finished")

	//TODO: make two routers and add TLS
	router := gin.Default()
	setupLogger(router)

	for _, r := range nest.Service_routes {
		switch r.Method {
		case "GET":
			router.GET(r.Pattern, r.HandlerFunc)
		case "POST":
			router.POST(r.Pattern, r.HandlerFunc)
		}
	}

	go router.Run(nest.Service_ip + ":" + nest.Service_port)
	//router.RunListener() per aggiungere tls
}
