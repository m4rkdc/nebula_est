/*
NEST: Nebula Enrollment over Secure Transport - OpenAPI 3.0

This package contains system-wide utility functions.
API version: 0.3.1
Contact: gianmarco.decola@studio.unibo.it
*/
package utils

import (
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

var (
	//A file in which to store the expected valid hostnames of the future Nebula network
	Hostnames_file string = "config/hostnames"
	//A folder in which to store all Nebula certificate signing request statuses for each host
	Ncsr_folder string = "ncsr/"
	//This service's log file
	Log_file string = "log/nest_service.log"
	//A file storing the Nebula certificate of the NEST CA
	Ca_cert_file string = "config/ca.crt"
	//This service's IP address
	Service_ip string = "localhost"
	//This service's port
	Service_port string = "8080"
	//The NEST CA service IP address on the NEST system Nebula network
	Ca_service_ip string = "192.168.80.1"
	//The NEST CA service port
	Ca_service_port string = "53535"
	//The NEST CONFIG service IP address on the NEST system Nebula network
	Conf_service_ip string = "192.168.80.2"
	//The NEST CONFIG service port
	Conf_service_port string = "61616"
	//Folder containing this service's NEST system Nebula network keys and configurations
	Nebula_folder string = "config/nebula/"
	//Generated certs validity. Valid time units are seconds: "s", minutes: "m", hours: "h"
	Certs_validity string = ""
	//Folder containing this service's TLS certificates and keys
	TLS_folder string = "config/tls/"
	//File containing the key used to sign HMACs
	HMAC_key string = "config/hmac.key"
	//Folder containing dhall-specific files used by the dhall-nebula tool
	Dhall_dir string = "dhall/"
	//File containing the general NEST client Nebula network specifications
	Dhall_configuration string = "dhall/nebula/nebula_conf.dhall"
	//Folder containing the NEST clients Nebula configuration files generated by this service
	Conf_gen_dir string = "dhall/nebula/generated/"
	//Folder to store the NEST client certificates generated by this service
	Certificates_path string = "certificates/"
	//The nebula-cert binary
	Ca_bin string = "config/bin/nebula-cert"
	//Folder containing NEST CA's Nebula certificate and private key used to sign client certificates
	Ca_keys_path string = "config/keys/"
)

// setupLogger sets up an io.Multiwriter that writes both on LOG_FILE and os.Stout for the given Gin router
func SetupLogger(router *gin.Engine, log_file string) error {
	logF, err := os.OpenFile(log_file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		return err
	}

	gin.ForceConsoleColor()
	router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
		Output: io.MultiWriter(logF, os.Stdout),
	}))
	return nil
}

// isExecOwner checks if an open file can be executed by its owner
func IsExecOwner(mode os.FileMode) bool {
	return mode&0100 != 0
}

// isRWOwner checks if an open file can be read and written by its owner
func IsRWOwner(mode os.FileMode) bool {
	return mode&0600 != 0
}

/*
setupNebula controls if the nebula binary is present in NEBULA_FOLDER and, if it is executable, executes it
to create a Nebula interface. If the interface is actually created, returns nil, err otherwise
*/
func SetupNebula(nebula_folder string) error {
	info, err := os.Stat(nebula_folder + "nebula")
	if err != nil {
		fmt.Printf("%s doesn't exist. Cannot proceed. Please provide the nebula bin to the service before starting it\nExiting...", nebula_folder+"nebula")
		return err
	}
	if !IsExecOwner(info.Mode()) {
		os.Chmod(nebula_folder+"nebula", 0700)
	}

	exec.Command(nebula_folder+"nebula", "-config", nebula_folder+"config.yml").Start()

	time.Sleep(2 * time.Second)
	interfaces, err := net.Interfaces()

	if err != nil {
		fmt.Printf("Could'nt check information about host interfaces\n")
		return err
	}

	var found bool = false
	for _, i := range interfaces {
		if strings.Contains(strings.ToLower(i.Name), "nebula") {
			found = true
			break
		}
	}

	if found {
		return nil
	}
	return errors.New("could not setup a nebula tunnel")
}
